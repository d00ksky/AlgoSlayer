#!/usr/bin/env python3\n\"\"\"\nComprehensive Options System Test\nTests all components of the new options trading system\n\"\"\"\nimport asyncio\nimport sys\nfrom datetime import datetime\nfrom loguru import logger\n\n# Configure logging\nlogger.remove()\nlogger.add(sys.stdout, level=\"INFO\", format=\"{time:HH:mm:ss} | {level} | {message}\")\n\n# Import all components\nfrom config.options_config import options_config\nfrom src.core.options_data_engine import options_data_engine\nfrom src.core.options_prediction_engine import options_prediction_engine\nfrom src.core.options_paper_trader import options_paper_trader\nfrom src.core.options_scheduler import options_scheduler\nfrom src.core.options_ml_integration import options_ml_integration\n\nasync def test_options_config():\n    \"\"\"Test options configuration\"\"\"\n    logger.info(\"🧪 Testing Options Configuration...\")\n    \n    # Test basic settings\n    assert options_config.EXPIRATION_PREFERENCE in [\"weekly\", \"monthly\", \"both\"]\n    assert options_config.STRIKE_SELECTION in [\"atm\", \"otm\", \"itm\", \"adaptive\"]\n    assert 0 < options_config.MAX_POSITION_SIZE_PCT <= 1.0\n    \n    # Test position sizing\n    size_1k = options_config.get_position_size(1000)\n    size_3k = options_config.get_position_size(3000)\n    \n    assert size_1k <= 200  # Should be capped at $200 for $1k account\n    assert size_3k <= 600  # Should be reasonable for $3k account\n    \n    # Test commission calculation\n    commission = options_config.calculate_commission(\"BUY_TO_OPEN\", 2)\n    assert commission >= 1.0  # Minimum commission\n    \n    logger.success(\"✅ Options configuration test passed\")\n    return True\n\nasync def test_options_data_engine():\n    \"\"\"Test options data fetching and validation\"\"\"\n    logger.info(\"🧪 Testing Options Data Engine...\")\n    \n    # Test data fetching\n    options_chain = options_data_engine.get_real_options_chain()\n    \n    if not options_chain:\n        logger.warning(\"⚠️ No options data available (market may be closed)\")\n        return True  # Not a failure if market is closed\n    \n    logger.info(f\"📊 Found {len(options_chain)} options contracts\")\n    \n    # Test data quality\n    sample_option = next(iter(options_chain.values()))\n    \n    # Check required fields\n    required_fields = ['type', 'strike', 'expiry', 'bid', 'ask', 'last', 'volume', 'openInterest']\n    for field in required_fields:\n        assert field in sample_option, f\"Missing field: {field}\"\n    \n    # Check data quality\n    assert sample_option['bid'] > 0, \"Invalid bid price\"\n    assert sample_option['ask'] > sample_option['bid'], \"Ask should be > bid\"\n    assert sample_option['strike'] > 0, \"Invalid strike price\"\n    \n    # Test best options selection\n    best_calls = options_data_engine.get_best_options_for_direction(\"BUY\", 0.8, 1000)\n    \n    if best_calls:\n        logger.info(f\"📈 Found {len(best_calls)} suitable call options\")\n        best_call = best_calls[0]\n        assert best_call['cost_per_contract'] <= 200, \"Option too expensive for $1k account\"\n    \n    logger.success(\"✅ Options data engine test passed\")\n    return True\n\nasync def test_options_prediction_engine():\n    \"\"\"Test options prediction generation\"\"\"\n    logger.info(\"🧪 Testing Options Prediction Engine...\")\n    \n    # Create mock signals data\n    mock_signals = {\n        'direction': 'BUY',\n        'confidence': 0.85,\n        'expected_move': 0.03,\n        'signals_agreeing': 6,\n        'total_signals': 8,\n        'individual_signals': {\n            'technical_analysis': {'direction': 'BUY', 'confidence': 0.8, 'strength': 0.15},\n            'momentum': {'direction': 'BUY', 'confidence': 0.75, 'strength': 0.12},\n            'news_sentiment': {'direction': 'BUY', 'confidence': 0.9, 'strength': 0.18}\n        },\n        'signal_weights': {\n            'technical_analysis': 0.15,\n            'momentum': 0.10,\n            'news_sentiment': 0.15\n        }\n    }\n    \n    # Test prediction generation\n    prediction = options_prediction_engine.generate_options_prediction(mock_signals, 1000)\n    \n    if not prediction:\n        logger.warning(\"⚠️ No prediction generated (market may be closed or no suitable options)\")\n        return True\n    \n    # Validate prediction structure\n    required_fields = [\n        'prediction_id', 'contract_symbol', 'action', 'entry_price', 'contracts',\n        'total_cost', 'confidence', 'expected_profit_pct', 'reasoning'\n    ]\n    \n    for field in required_fields:\n        assert field in prediction, f\"Missing prediction field: {field}\"\n    \n    # Validate prediction values\n    assert prediction['confidence'] >= 0.75, \"Confidence should be >= 75% for options\"\n    assert prediction['total_cost'] <= 1000, \"Trade cost exceeds account balance\"\n    assert prediction['contracts'] > 0, \"Must have positive contracts\"\n    \n    logger.info(f\"🎯 Generated prediction: {prediction['action']} {prediction['contract_symbol']}\")\n    logger.info(f\"💰 Total cost: ${prediction['total_cost']:.2f} for {prediction['contracts']} contracts\")\n    \n    logger.success(\"✅ Options prediction engine test passed\")\n    return prediction\n\nasync def test_options_paper_trader(sample_prediction):\n    \"\"\"Test options paper trading simulation\"\"\"\n    logger.info(\"🧪 Testing Options Paper Trader...\")\n    \n    if not sample_prediction:\n        logger.warning(\"⚠️ No prediction to test paper trading\")\n        return True\n    \n    # Test opening position\n    initial_balance = options_paper_trader.account_balance\n    \n    success = options_paper_trader.open_position(sample_prediction)\n    \n    if not success:\n        logger.warning(\"⚠️ Could not open paper position (may be due to market hours)\")\n        return True\n    \n    # Check account balance updated\n    new_balance = options_paper_trader.account_balance\n    assert new_balance < initial_balance, \"Account balance should decrease after opening position\"\n    \n    # Check position tracking\n    open_positions = options_paper_trader.get_open_positions_summary()\n    assert len(open_positions) > 0, \"Should have open positions\"\n    \n    # Test position checking\n    actions = options_paper_trader.check_positions()\n    logger.info(f\"📊 Position check actions: {actions}\")\n    \n    # Get performance summary\n    performance = options_paper_trader.get_performance_summary()\n    \n    assert 'account_balance' in performance\n    assert 'total_trades' in performance\n    assert 'win_rate' in performance\n    \n    logger.info(f\"💰 Account balance: ${performance['account_balance']:.2f}\")\n    logger.info(f\"📊 Open positions: {performance['open_positions_count']}\")\n    \n    logger.success(\"✅ Options paper trader test passed\")\n    return True\n\nasync def test_options_scheduler():\n    \"\"\"Test options scheduler functionality\"\"\"\n    logger.info(\"🧪 Testing Options Scheduler...\")\n    \n    # Test signal generation\n    try:\n        signals_data = await options_scheduler._generate_signals()\n        \n        if signals_data:\n            assert 'direction' in signals_data\n            assert 'confidence' in signals_data\n            assert 'individual_signals' in signals_data\n            \n            logger.info(f\"🤖 Generated signals: {signals_data['direction']} ({signals_data['confidence']:.1%})\")\n            \n            # Test prediction creation\n            if signals_data['confidence'] >= 0.75:\n                prediction = await options_scheduler._create_options_prediction(signals_data)\n                if prediction:\n                    logger.info(f\"🎯 Created prediction: {prediction['contract_symbol']}\")\n        \n        logger.success(\"✅ Options scheduler test passed\")\n        return True\n        \n    except Exception as e:\n        logger.error(f\"❌ Scheduler test failed: {e}\")\n        return False\n\nasync def test_options_ml_integration():\n    \"\"\"Test ML integration for options\"\"\"\n    logger.info(\"🧪 Testing Options ML Integration...\")\n    \n    # Test data extraction\n    training_data = options_ml_integration.extract_options_training_data()\n    \n    if training_data.empty:\n        logger.info(\"📊 No historical options data for ML training (expected for new system)\")\n    else:\n        logger.info(f\"📊 Found {len(training_data)} historical trades\")\n        \n        # Test feature engineering\n        features, labels = options_ml_integration.engineer_options_features(training_data)\n        \n        if not features.empty:\n            logger.info(f\"🔧 Engineered {len(features.columns)} features\")\n            \n            # Test signal performance analysis\n            signal_perf = options_ml_integration.analyze_signal_performance(training_data)\n            logger.info(f\"📊 Analyzed {len(signal_perf)} signals\")\n    \n    # Test insights generation\n    insights = options_ml_integration.generate_options_insights()\n    \n    assert 'generated_at' in insights\n    \n    if 'error' not in insights:\n        logger.info(f\"🧠 Generated insights for {insights['total_trades']} trades\")\n    \n    logger.success(\"✅ Options ML integration test passed\")\n    return True\n\nasync def test_integration():\n    \"\"\"Test full system integration\"\"\"\n    logger.info(\"🧪 Testing Full System Integration...\")\n    \n    # Test scheduler status\n    status = options_scheduler.get_status()\n    \n    assert 'running' in status\n    assert 'account_balance' in status\n    assert 'performance' in status\n    \n    logger.info(f\"🔄 Scheduler status: {'Running' if status['running'] else 'Stopped'}\")\n    logger.info(f\"💰 Account balance: ${status['account_balance']:.2f}\")\n    \n    # Test market hours detection\n    market_open = options_config.is_market_hours()\n    logger.info(f\"📅 Market hours: {'Open' if market_open else 'Closed'}\")\n    \n    logger.success(\"✅ Full system integration test passed\")\n    return True\n\nasync def main():\n    \"\"\"Run all tests\"\"\"\n    logger.info(\"🚀 Starting Comprehensive Options System Test\")\n    logger.info(\"=\" * 60)\n    \n    tests = [\n        (\"Options Config\", test_options_config()),\n        (\"Options Data Engine\", test_options_data_engine()),\n        (\"Options Prediction Engine\", test_options_prediction_engine()),\n    ]\n    \n    # Run first batch of tests\n    prediction = None\n    passed_tests = 0\n    \n    for test_name, test_coro in tests:\n        try:\n            result = await test_coro\n            if test_name == \"Options Prediction Engine\":\n                prediction = result\n            if result:\n                passed_tests += 1\n            else:\n                logger.error(f\"❌ {test_name} failed\")\n        except Exception as e:\n            logger.error(f\"❌ {test_name} failed with error: {e}\")\n    \n    # Test paper trader with prediction\n    try:\n        result = await test_options_paper_trader(prediction if isinstance(prediction, dict) else None)\n        if result:\n            passed_tests += 1\n    except Exception as e:\n        logger.error(f\"❌ Options Paper Trader failed: {e}\")\n    \n    # Test remaining components\n    remaining_tests = [\n        (\"Options Scheduler\", test_options_scheduler()),\n        (\"Options ML Integration\", test_options_ml_integration()),\n        (\"System Integration\", test_integration()),\n    ]\n    \n    for test_name, test_coro in remaining_tests:\n        try:\n            result = await test_coro\n            if result:\n                passed_tests += 1\n        except Exception as e:\n            logger.error(f\"❌ {test_name} failed: {e}\")\n    \n    total_tests = len(tests) + 1 + len(remaining_tests)  # +1 for paper trader\n    \n    logger.info(\"=\" * 60)\n    \n    if passed_tests == total_tests:\n        logger.success(f\"🎉 ALL TESTS PASSED! ({passed_tests}/{total_tests})\")\n        logger.success(\"🚀 RTX Options Trading System is ready for deployment!\")\n        \n        # Show system summary\n        logger.info(\"\\n📊 SYSTEM SUMMARY:\")\n        logger.info(f\"• Configuration: {options_config.EXPIRATION_PREFERENCE} expiry, {options_config.STRIKE_SELECTION} strikes\")\n        logger.info(f\"• Account Balance: ${options_paper_trader.account_balance:.2f}\")\n        logger.info(f\"• Max Position Size: {options_config.MAX_POSITION_SIZE_PCT:.0%} of capital\")\n        logger.info(f\"• Market Hours: {'Open' if options_config.is_market_hours() else 'Closed'}\")\n        logger.info(f\"• Ready for: High-conviction RTX options trading with real learning\")\n        \n    else:\n        logger.error(f\"❌ SOME TESTS FAILED: {passed_tests}/{total_tests} passed\")\n        logger.error(\"🔧 Please review and fix issues before deployment\")\n        return False\n    \n    return True\n\nif __name__ == \"__main__\":\n    # Run the comprehensive test\n    asyncio.run(main())"